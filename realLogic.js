import ytdl from "ytdl-core"
import axios from "axios"
import fs from "fs"
import path from "path"
import { fileURLToPath } from "url"
import { watermarkImage, watermarkVideo } from "./utils.js"

const __filename = fileURLToPath(import.meta.url)
const __dirname = path.dirname(__filename)

// Real YouTube Download Logic
export async function downloadYouTubeAudio(url, sock, sender, brandSignature) {
  try {
    // Validate YouTube URL
    if (!ytdl.validateURL(url)) {
      return await sock.sendMessage(sender, {
        text: `‚ùå Invalid YouTube URL provided.${brandSignature}`,
      })
    }

    // Get video info
    const info = await ytdl.getInfo(url)
    const title = info.videoDetails.title
    const duration = Number.parseInt(info.videoDetails.lengthSeconds)

    // Check duration limit (10 minutes = 600 seconds)
    if (duration > 600) {
      return await sock.sendMessage(sender, {
        text: `‚ùå Video too long! Maximum duration is 10 minutes.\nVideo duration: ${Math.floor(duration / 60)}:${duration % 60}${brandSignature}`,
      })
    }

    // Send processing message
    await sock.sendMessage(sender, {
      text: `üéµ *Downloading: ${title}*\n\n‚è≥ Processing audio... Please wait.${brandSignature}`,
    })

    // Download audio
    const audioPath = path.join(__dirname, "temp", `${Date.now()}.mp3`)
    const audioStream = ytdl(url, {
      filter: "audioonly",
      quality: "highestaudio",
    })

    // Ensure temp directory exists
    const tempDir = path.dirname(audioPath)
    if (!fs.existsSync(tempDir)) {
      fs.mkdirSync(tempDir, { recursive: true })
    }

    // Save audio file
    const writeStream = fs.createWriteStream(audioPath)
    audioStream.pipe(writeStream)

    return new Promise((resolve, reject) => {
      writeStream.on("finish", async () => {
        try {
          // Send audio file
          await sock.sendMessage(sender, {
            audio: { url: audioPath },
            mimetype: "audio/mpeg",
            ptt: false,
            contextInfo: {
              externalAdReply: {
                title: title,
                body: "Lil Gaga Traxx09 Images",
                thumbnailUrl: info.videoDetails.thumbnails[0]?.url,
                sourceUrl: url,
                mediaType: 2,
                renderLargerThumbnail: true,
              },
            },
          })

          // Clean up temp file
          fs.unlinkSync(audioPath)

          await sock.sendMessage(sender, {
            text: `‚úÖ *Audio Downloaded Successfully!*\n\nüéµ *Title:* ${title}\n‚è±Ô∏è *Duration:* ${Math.floor(duration / 60)}:${String(duration % 60).padStart(2, "0")}${brandSignature}`,
          })

          resolve()
        } catch (error) {
          console.error("Error sending audio:", error)
          fs.unlinkSync(audioPath) // Clean up on error
          reject(error)
        }
      })

      writeStream.on("error", (error) => {
        console.error("Error writing audio file:", error)
        reject(error)
      })
    })
  } catch (error) {
    console.error("YouTube download error:", error)
    return await sock.sendMessage(sender, {
      text: `‚ùå Failed to download audio. Please try again later.\n\nError: ${error.message}${brandSignature}`,
    })
  }
}

export async function downloadYouTubeVideo(url, sock, sender, brandSignature) {
  try {
    if (!ytdl.validateURL(url)) {
      return await sock.sendMessage(sender, {
        text: `‚ùå Invalid YouTube URL provided.${brandSignature}`,
      })
    }

    const info = await ytdl.getInfo(url)
    const title = info.videoDetails.title
    const duration = Number.parseInt(info.videoDetails.lengthSeconds)

    if (duration > 600) {
      return await sock.sendMessage(sender, {
        text: `‚ùå Video too long! Maximum duration is 10 minutes.\nVideo duration: ${Math.floor(duration / 60)}:${duration % 60}${brandSignature}`,
      })
    }

    await sock.sendMessage(sender, {
      text: `üé¨ *Downloading: ${title}*\n\n‚è≥ Processing video... Please wait.${brandSignature}`,
    })

    const videoPath = path.join(__dirname, "temp", `${Date.now()}.mp4`)
    const videoStream = ytdl(url, {
      filter: "videoandaudio",
      quality: "highest",
    })

    const tempDir = path.dirname(videoPath)
    if (!fs.existsSync(tempDir)) {
      fs.mkdirSync(tempDir, { recursive: true })
    }

    const writeStream = fs.createWriteStream(videoPath)
    videoStream.pipe(writeStream)

    return new Promise((resolve, reject) => {
      writeStream.on("finish", async () => {
        try {
          // Add watermark to video
          const watermarkedPath = await watermarkVideo(videoPath, "Lil Gaga Traxx09 Images")

          // Send video file
          await sock.sendMessage(sender, {
            video: { url: watermarkedPath },
            caption: `üé¨ *${title}*\n\n‚è±Ô∏è Duration: ${Math.floor(duration / 60)}:${String(duration % 60).padStart(2, "0")}\nüè∑Ô∏è Watermarked by Lil Gaga Traxx09${brandSignature}`,
            contextInfo: {
              externalAdReply: {
                title: title,
                body: "Lil Gaga Traxx09 Images",
                thumbnailUrl: info.videoDetails.thumbnails[0]?.url,
                sourceUrl: url,
                mediaType: 1,
                renderLargerThumbnail: true,
              },
            },
          })

          // Clean up temp files
          fs.unlinkSync(videoPath)
          if (watermarkedPath !== videoPath) {
            fs.unlinkSync(watermarkedPath)
          }

          resolve()
        } catch (error) {
          console.error("Error sending video:", error)
          fs.unlinkSync(videoPath)
          reject(error)
        }
      })

      writeStream.on("error", reject)
    })
  } catch (error) {
    console.error("YouTube video download error:", error)
    return await sock.sendMessage(sender, {
      text: `‚ùå Failed to download video. Please try again later.\n\nError: ${error.message}${brandSignature}`,
    })
  }
}

// Real AI Integration Logic
export async function callOpenAI(prompt, sock, sender, brandSignature) {
  try {
    if (!process.env.OPENAI_API_KEY) {
      return await sock.sendMessage(sender, {
        text: `‚ùå OpenAI API key not configured. Please contact the bot owner.${brandSignature}`,
      })
    }

    await sock.sendMessage(sender, {
      text: `ü§ñ *Processing your request...*\n\n‚ùì *Question:* ${prompt}\n\n‚è≥ AI is thinking... Please wait.${brandSignature}`,
    })

    const response = await axios.post(
      "https://api.openai.com/v1/chat/completions",
      {
        model: "gpt-3.5-turbo",
        messages: [
          {
            role: "system",
            content:
              "You are Gaga09 XMD, a helpful WhatsApp bot created by Lil Gaga Traxx09. Provide helpful, accurate, and friendly responses. Keep responses concise but informative.",
          },
          {
            role: "user",
            content: prompt,
          },
        ],
        max_tokens: 1000,
        temperature: 0.7,
      },
      {
        headers: {
          Authorization: `Bearer ${process.env.OPENAI_API_KEY}`,
          "Content-Type": "application/json",
        },
      },
    )

    const aiResponse = response.data.choices[0].message.content

    return await sock.sendMessage(sender, {
      text: `ü§ñ *AI Response:*\n\n${aiResponse}${brandSignature}`,
    })
  } catch (error) {
    console.error("OpenAI API error:", error)
    return await sock.sendMessage(sender, {
      text: `‚ùå AI service temporarily unavailable. Please try again later.\n\nError: ${error.response?.data?.error?.message || error.message}${brandSignature}`,
    })
  }
}

export async function callGeminiAI(prompt, sock, sender, brandSignature) {
  try {
    if (!process.env.GEMINI_API_KEY) {
      return await sock.sendMessage(sender, {
        text: `‚ùå Gemini API key not configured. Please contact the bot owner.${brandSignature}`,
      })
    }

    await sock.sendMessage(sender, {
      text: `ü§ñ *Gemini AI Processing...*\n\n‚ùì *Question:* ${prompt}\n\n‚è≥ Generating response... Please wait.${brandSignature}`,
    })

    const response = await axios.post(
      `https://generativelanguage.googleapis.com/v1beta/models/gemini-pro:generateContent?key=${process.env.GEMINI_API_KEY}`,
      {
        contents: [
          {
            parts: [
              {
                text: `You are Gaga09 XMD, a WhatsApp bot created by Lil Gaga Traxx09. Answer this question helpfully and concisely: ${prompt}`,
              },
            ],
          },
        ],
      },
      {
        headers: {
          "Content-Type": "application/json",
        },
      },
    )

    const aiResponse = response.data.candidates[0].content.parts[0].text

    return await sock.sendMessage(sender, {
      text: `ü§ñ *Gemini AI Response:*\n\n${aiResponse}${brandSignature}`,
    })
  } catch (error) {
    console.error("Gemini API error:", error)
    return await sock.sendMessage(sender, {
      text: `‚ùå Gemini AI service temporarily unavailable. Please try again later.\n\nError: ${error.response?.data?.error?.message || error.message}${brandSignature}`,
    })
  }
}

// Real Media Fetch Logic
export async function fetchMediaFromURL(url, sock, sender, brandSignature) {
  try {
    // Validate URL
    const urlPattern = /^https?:\/\/.+/i
    if (!urlPattern.test(url)) {
      return await sock.sendMessage(sender, {
        text: `‚ùå Invalid URL provided. Please provide a valid HTTP/HTTPS URL.${brandSignature}`,
      })
    }

    await sock.sendMessage(sender, {
      text: `üì• *Fetching media from URL...*\n\nüîó *URL:* ${url}\n\n‚è≥ Analyzing file... Please wait.${brandSignature}`,
    })

    // Get file info
    const headResponse = await axios.head(url, { timeout: 10000 })
    const contentType = headResponse.headers["content-type"] || ""
    const contentLength = Number.parseInt(headResponse.headers["content-length"] || "0")

    // Check file size (50MB limit)
    const maxSize = 50 * 1024 * 1024 // 50MB
    if (contentLength > maxSize) {
      return await sock.sendMessage(sender, {
        text: `‚ùå File too large! Maximum size is 50MB.\nFile size: ${(contentLength / 1024 / 1024).toFixed(2)}MB${brandSignature}`,
      })
    }

    // Download file
    const response = await axios.get(url, {
      responseType: "arraybuffer",
      timeout: 30000,
      maxContentLength: maxSize,
    })

    const buffer = Buffer.from(response.data)
    const fileName = path.basename(url.split("?")[0]) || "downloaded_file"

    // Determine file type and send accordingly
    if (contentType.startsWith("image/")) {
      // Add watermark to image
      const watermarkedBuffer = await watermarkImage(buffer, "Lil Gaga Traxx09 Images")

      await sock.sendMessage(sender, {
        image: watermarkedBuffer,
        caption: `üì∏ *Image Downloaded*\n\nüîó Source: ${url}\nüè∑Ô∏è Watermarked by Lil Gaga Traxx09${brandSignature}`,
      })
    } else if (contentType.startsWith("video/")) {
      // Save video temporarily for watermarking
      const tempPath = path.join(__dirname, "temp", `${Date.now()}_${fileName}`)
      fs.writeFileSync(tempPath, buffer)

      // Add watermark to video
      const watermarkedPath = await watermarkVideo(tempPath, "Lil Gaga Traxx09 Images")

      await sock.sendMessage(sender, {
        video: { url: watermarkedPath },
        caption: `üé¨ *Video Downloaded*\n\nüîó Source: ${url}\nüè∑Ô∏è Watermarked by Lil Gaga Traxx09${brandSignature}`,
      })

      // Clean up temp files
      fs.unlinkSync(tempPath)
      if (watermarkedPath !== tempPath) {
        fs.unlinkSync(watermarkedPath)
      }
    } else if (contentType.startsWith("audio/")) {
      await sock.sendMessage(sender, {
        audio: buffer,
        mimetype: contentType,
        ptt: false,
      })

      await sock.sendMessage(sender, {
        text: `üéµ *Audio Downloaded*\n\nüîó Source: ${url}${brandSignature}`,
      })
    } else {
      // Send as document
      await sock.sendMessage(sender, {
        document: buffer,
        fileName: fileName,
        mimetype: contentType || "application/octet-stream",
      })

      await sock.sendMessage(sender, {
        text: `üìÑ *File Downloaded*\n\nüìÅ Name: ${fileName}\nüìä Size: ${(buffer.length / 1024).toFixed(2)} KB\nüîó Source: ${url}${brandSignature}`,
      })
    }
  } catch (error) {
    console.error("Media fetch error:", error)

    let errorMessage = "‚ùå Failed to fetch media from URL."

    if (error.code === "ENOTFOUND") {
      errorMessage += "\n\nüåê URL not found or server unreachable."
    } else if (error.code === "ETIMEDOUT") {
      errorMessage += "\n\n‚è∞ Request timed out. Server may be slow."
    } else if (error.response?.status === 404) {
      errorMessage += "\n\nüìÑ File not found (404 error)."
    } else if (error.response?.status === 403) {
      errorMessage += "\n\nüîí Access denied (403 error)."
    }

    return await sock.sendMessage(sender, {
      text: `${errorMessage}${brandSignature}`,
    })
  }
}

// Real Session Management Logic
export async function exportSession(sock, sender, brandSignature) {
  try {
    const sessionDir = path.join(__dirname, "session")

    if (!fs.existsSync(sessionDir)) {
      return await sock.sendMessage(sender, {
        text: `‚ùå No session data found. Please pair the bot first.${brandSignature}`,
      })
    }

    // Read session files
    const sessionData = {}
    const files = fs.readdirSync(sessionDir)

    for (const file of files) {
      if (file.endsWith(".json")) {
        const filePath = path.join(sessionDir, file)
        const content = fs.readFileSync(filePath, "utf8")
        sessionData[file] = JSON.parse(content)
      }
    }

    // Convert to base64
    const sessionString = JSON.stringify(sessionData)
    const base64Session = Buffer.from(sessionString).toString("base64")

    // Send session data
    await sock.sendMessage(sender, {
      text: `üíæ *Session Export Successful*\n\nüîê *Session ID (Base64):*\n\`\`\`${base64Session}\`\`\`\n\n‚ö†Ô∏è *Security Warning:*\n‚Ä¢ Keep this data private\n‚Ä¢ Don't share with unauthorized users\n‚Ä¢ Use secure channels for transfer\n\nüí° *Usage:*\nUse \`.setsession ${base64Session.substring(0, 20)}...\` on target device${brandSignature}`,
    })

    // Also send as document for easy copying
    const sessionFile = Buffer.from(base64Session)
    await sock.sendMessage(sender, {
      document: sessionFile,
      fileName: `gaga09_session_${Date.now()}.txt`,
      mimetype: "text/plain",
    })
  } catch (error) {
    console.error("Session export error:", error)
    return await sock.sendMessage(sender, {
      text: `‚ùå Failed to export session data.\n\nError: ${error.message}${brandSignature}`,
    })
  }
}

export async function importSession(sessionData, sock, sender, brandSignature) {
  try {
    if (!sessionData) {
      return await sock.sendMessage(sender, {
        text: `‚ùå No session data provided.\n\nUsage: .setsession [base64-data]${brandSignature}`,
      })
    }

    await sock.sendMessage(sender, {
      text: `üíæ *Importing Session...*\n\n‚è≥ Processing session data... Please wait.${brandSignature}`,
    })

    // Decode base64 session data
    let decodedData
    try {
      decodedData = Buffer.from(sessionData, "base64").toString("utf8")
    } catch (error) {
      return await sock.sendMessage(sender, {
        text: `‚ùå Invalid session data format. Please provide valid base64 encoded session.${brandSignature}`,
      })
    }

    // Parse JSON
    let sessionObject
    try {
      sessionObject = JSON.parse(decodedData)
    } catch (error) {
      return await sock.sendMessage(sender, {
        text: `‚ùå Invalid session data structure. Please provide valid session JSON.${brandSignature}`,
      })
    }

    // Create session directory
    const sessionDir = path.join(__dirname, "session")
    if (!fs.existsSync(sessionDir)) {
      fs.mkdirSync(sessionDir, { recursive: true })
    }

    // Write session files
    for (const [fileName, fileData] of Object.entries(sessionObject)) {
      const filePath = path.join(sessionDir, fileName)
      fs.writeFileSync(filePath, JSON.stringify(fileData, null, 2))
    }

    await sock.sendMessage(sender, {
      text: `‚úÖ *Session Import Successful!*\n\nüíæ Session data has been imported\nüîÑ Bot will reconnect automatically\n‚è±Ô∏è Please wait 10-30 seconds\n\nüí° Use .alive to check connection status${brandSignature}`,
    })

    // Trigger reconnection (this would need to be handled by the main server)
    setTimeout(() => {
      process.exit(0) // Restart the bot to use new session
    }, 2000)
  } catch (error) {
    console.error("Session import error:", error)
    return await sock.sendMessage(sender, {
      text: `‚ùå Failed to import session data.\n\nError: ${error.message}${brandSignature}`,
    })
  }
}

// Real Calculator Logic
export function calculateExpression(expression) {
  try {
    // Sanitize expression - only allow numbers, operators, parentheses, and decimal points
    const sanitized = expression.replace(/[^0-9+\-*/().\s]/g, "")

    if (!sanitized) {
      throw new Error("Invalid expression")
    }

    // Use Function constructor for safe evaluation (better than eval)
    const result = new Function("return " + sanitized)()

    if (typeof result !== "number" || !isFinite(result)) {
      throw new Error("Invalid calculation result")
    }

    return {
      success: true,
      result: result,
      expression: sanitized,
    }
  } catch (error) {
    return {
      success: false,
      error: error.message,
      expression: expression,
    }
  }
}

// Real Reminder Logic
const activeReminders = new Map()

export function setReminder(timeString, message, sender, sock, brandSignature) {
  try {
    // Parse time string (e.g., "5m", "1h", "2d")
    const timeMatch = timeString.match(/^(\d+)([mhd])$/i)
    if (!timeMatch) {
      return {
        success: false,
        error: "Invalid time format. Use: 5m (minutes), 1h (hours), 2d (days)",
      }
    }

    const amount = Number.parseInt(timeMatch[1])
    const unit = timeMatch[2].toLowerCase()

    let milliseconds
    switch (unit) {
      case "m":
        milliseconds = amount * 60 * 1000
        break
      case "h":
        milliseconds = amount * 60 * 60 * 1000
        break
      case "d":
        milliseconds = amount * 24 * 60 * 60 * 1000
        break
      default:
        return {
          success: false,
          error: "Invalid time unit. Use m (minutes), h (hours), d (days)",
        }
    }

    // Set maximum reminder time (7 days)
    const maxTime = 7 * 24 * 60 * 60 * 1000
    if (milliseconds > maxTime) {
      return {
        success: false,
        error: "Maximum reminder time is 7 days",
      }
    }

    const reminderId = `${sender}_${Date.now()}`
    const reminderTime = new Date(Date.now() + milliseconds)

    // Set timeout for reminder
    const timeoutId = setTimeout(async () => {
      try {
        await sock.sendMessage(sender, {
          text: `‚è∞ *REMINDER*\n\nüìù *Message:* ${message}\n‚è±Ô∏è *Set at:* ${new Date(Date.now() - milliseconds).toLocaleString()}\nüìÖ *Reminder time:* ${new Date().toLocaleString()}${brandSignature}`,
        })

        // Remove from active reminders
        activeReminders.delete(reminderId)
      } catch (error) {
        console.error("Error sending reminder:", error)
      }
    }, milliseconds)

    // Store reminder info
    activeReminders.set(reminderId, {
      timeoutId,
      message,
      sender,
      reminderTime,
      timeString,
    })

    return {
      success: true,
      reminderId,
      reminderTime,
      timeString,
      message,
    }
  } catch (error) {
    return {
      success: false,
      error: error.message,
    }
  }
}

export function cancelReminder(reminderId) {
  const reminder = activeReminders.get(reminderId)
  if (reminder) {
    clearTimeout(reminder.timeoutId)
    activeReminders.delete(reminderId)
    return true
  }
  return false
}

export function getActiveReminders(sender) {
  const userReminders = []
  for (const [id, reminder] of activeReminders.entries()) {
    if (reminder.sender === sender) {
      userReminders.push({
        id,
        message: reminder.message,
        reminderTime: reminder.reminderTime,
        timeString: reminder.timeString,
      })
    }
  }
  return userReminders
}

// Emoji Command Handler
export function handleEmojiCommand(text) {
  if (!text) {
    return `üòÄ *Emoji Converter*

Usage: .emoji [text]

Examples:
.emoji hello world
.emoji I love coding
.emoji good morning

üé® *Features:*
‚Ä¢ Convert text to emojis
‚Ä¢ Multiple emoji styles
‚Ä¢ Creative text transformation
‚Ä¢ Fun and expressive output

üí° *Try different words to see various emoji combinations!*`
  }

  // Simple emoji conversion (in production, use a proper emoji library)
  const emojiText = text
    .replace(/hello/gi, "üëã")
    .replace(/hi/gi, "üëã")
    .replace(/love/gi, "‚ù§Ô∏è")
    .replace(/heart/gi, "üíñ")
    .replace(/happy/gi, "üòä")
    .replace(/smile/gi, "üòÑ")
    .replace(/sad/gi, "üò¢")
    .replace(/cry/gi, "üò≠")
    .replace(/fire/gi, "üî•")
    .replace(/hot/gi, "üî•")
    .replace(/star/gi, "‚≠ê")
    .replace(/cool/gi, "üòé")
    .replace(/good/gi, "üëç")
    .replace(/bad/gi, "üëé")
    .replace(/morning/gi, "üåÖ")
    .replace(/night/gi, "üåô")
    .replace(/sun/gi, "‚òÄÔ∏è")
    .replace(/moon/gi, "üåô")
    .replace(/music/gi, "üéµ")
    .replace(/dance/gi, "üíÉ")
    .replace(/party/gi, "üéâ")
    .replace(/food/gi, "üçï")
    .replace(/coffee/gi, "‚òï")
    .replace(/water/gi, "üíß")
    .replace(/car/gi, "üöó")
    .replace(/home/gi, "üè†")
    .replace(/work/gi, "üíº")
    .replace(/money/gi, "üí∞")
    .replace(/time/gi, "‚è∞")
    .replace(/phone/gi, "üì±")
    .replace(/computer/gi, "üíª")
    .replace(/book/gi, "üìö")
    .replace(/game/gi, "üéÆ")

  return `üòÄ *Emoji Conversion Result*

üìù *Original:* ${text}
üòä *With Emojis:* ${emojiText}

üé® *More emoji styles:*
üî§ *Bold Style:* **${emojiText}**
‚ú® *Sparkle Style:* ‚ú®${emojiText}‚ú®
üåü *Star Style:* ‚≠ê${emojiText}‚≠ê

üí° *Tip:* Try words like love, fire, star, happy, cool for more emojis!`
}
